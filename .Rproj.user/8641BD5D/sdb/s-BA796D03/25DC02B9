{
    "contents" : "---\ntitle: \"Antarctic Whale Project: Single Species\"\nauthor: \"Ben Weinstein\"\ndate: \"`r Sys.time()`\"\noutput: \n  html_document:\n    keep_md: true\n    number_sections: true\n    toc: true\n    theme: spacelab\n---\n\n```{r,warning=FALSE,message=FALSE,echo=FALSE}\nlibrary(knitr)\nopts_chunk$set(echo=F,warning=F,message=F,fig.width = 11,fig.height = 5)\nlibrary(boot)\nlibrary(raster)\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(survival)\nlibrary(MASS)\nlibrary(ggmap)\nlibrary(dplyr)\nlibrary(chron)\nlibrary(gridExtra)\nlibrary(stringr)\nlibrary(R2jags)\nlibrary(move)\n\n#New model to be run, flag turned off if just updating.\nnewModel<-TRUE\n```\n\n```{r,eval=F}\n#Load in data\nload(\"SingleSpecies.RData\")\n#jags$recompile()\nnewModel<-F\n```\n\n#Abstract\n\n```{r}\nmdat<-read.csv(\"InputData/FullData-550793189439001813.csv\")\n\n##need to look into making into a movebank object.\n\n#Create a oceandepth in km \nmdat$ocean<-mdat$ETOPO1.Elevation * -1 /1000\n\n#standardize column names to match the simulation\n#Create an animal tag.\nmxy <- as(mdat, \"data.frame\")\nmxy$Animal<-mxy$individual.local.identifier\nmxy$x<-mxy$location.long\nmxy$y<-mxy$location.lat\n\n#grab set of animals\nmxy<-mxy[mxy$Animal %in% c(\"112703\",\"121211\",\"131132\",\"112737\",\"131156\",\"12326\",\"123232\",\"112705\",\"154187\",\"121210\",\"131134\",\"131141\",\"112701\",\"131159\"),]\n\nmxy$Animal<-as.numeric(as.factor(mxy$Animal))\n\n#set datestamp\nmxy$timestamp<-as.POSIXct(mxy$timestamp,format=\"%Y-%m-%d %H:%M:%S.000\")\n\n#remove empty timestamps\nmxy<-mxy[!is.na(mxy$timestamp),]\n```\n\n#Descriptive Statistics\n```{r}\n#no distance to coast,elevation\nmxy<-mxy[!mxy$ETOPO1.Elevation>0,]\n\n```\n\n```{r}\n#Plot\npp<-c(mean(mxy$x),mean(mxy$y))\nm <- get_map(location=pp,source=\"google\",zoom=4,scale=2,maptype=\"satellite\")\nggmap(m)+geom_path(data=mxy, aes(x=x, y=y,col=as.factor(Animal)),size=.5) + labs(col=\"Whale\")\n```\n\n##Distance\n\n```{r,fig.height=3}\nmoved<-move(x=mxy$x,y=mxy$y,time=as.POSIXct(mxy$timestamp),proj=CRS(\"+proj=longlat +ellps=WGS84\"),animal=mxy$Animal,data=as.data.frame(mxy),sensor=mxy$Animal,removeDuplicatedTimestamps=T)\ndstat<-melt(move::distanceSummary(moved))\n\ndstat<-droplevels(dstat[dstat$variable %in% c(\"TravDist\",\"AverDist\",\"FarthDist\"),])\nlevels(dstat$variable)<-c(\"Total Distance (km)\",\"Average Distance Between Points\",\"Farthest Distance Between Points\")\nggplot(dstat,aes(value/1000)) + geom_histogram() + facet_wrap(~variable,scales=\"free\")\n```\n\n##Time \n```{r,fig.height=3}\ntstat<-move::timeSummary(moved)\ntstat<-melt(tstat,measure.vars=colnames(tstat[[1]]))\ntstat<-droplevels(tstat[tstat$variable %in% c(\"Duration\",\"AverDur\"),])\nlevels(tstat$variable)<-c(\"Total Time (Hours)\",\"Average Time Between Points (Hours)\")\nggplot(tstat,aes(value)) + geom_histogram() + facet_wrap(~variable,scales=\"free\")\n```\n\n##Velocity\n```{r,fig.height=3}\nvstat<-move::speedSummary(moved)\nvstat<-melt(vstat,measure.vars=colnames(vstat[[1]]))\nlevels(vstat$variable)<-c(\"Average Speed (m/s)\",\"Variance in Speed (m/s)\",\"Max Speed (m/s)\")\nggplot(vstat,aes(value)) + geom_histogram() + facet_wrap(~variable,scales=\"free\")\n```\n\n##Angles\n\n```{r,fig.height=2}\nastat<-move::angleSummary(moved)\nastat<-melt(astat,measure.vars=colnames(astat[[1]]))\nastat<-droplevels(astat[astat$variable %in% \"AverAzimuth\",])\nlevels(astat$variable)<-\"Turning Angle (degrees)\"\nggplot(astat,aes(value)) + geom_histogram() + facet_wrap(~variable,scales=\"free\")\n```\n\n#Correlated random walk\n\n*Process Model*\n\n$$ d_{t} \\sim T*d_{t-1} + Normal(0,\\Sigma)$$\n$$ x_t = x_{t-1} + d_{t} $$\n\n## Parameters\n\nFor each individual:\n\n$$\\theta = \\text{Mean turning angle}$$\n$$\\gamma = \\text{Move persistence} $$\n\nFor both behaviors process variance is:\n$$ \\sigma_{latitude} = 0.1$$\n$$ \\sigma_{longitude} = 0.1$$\n\n##Behavioral States\n\n$$ \\text{For each individual i}$$\n$$ Behavior_1 = \\text{traveling}$$\n$$ Behavior_2 = \\text{foraging}$$\n\n$$ \\alpha_{i,1,1} = \\text{Probability of remaining traveling when traveling}$$\n$$\\alpha_{i,2,1} = \\text{Probability of switching from feeding to traveling}$$\n\n$$\\begin{matrix}\n  \\alpha_{i,1,1} & 1-\\alpha_{i,1,1} \\\\\n  \\alpha_{i,2,1} & 1-\\alpha_{i,2,1} \\\\\n\\end{matrix}\n$$\n\n##Environment\n\nBehavioral states are a function of local environmental conditions. The first environmental condition is ocean depth. I then build a function for preferential foraging in shallow waters.\n\nIt generally follows the form, conditional on behavior at t -1:\n\n$$Behavior_t \\sim Multinomial([\\phi_{traveling},\\phi_{foraging}])$$\n$$logit(\\phi_{traveling}) = \\alpha_{Behavior_{t-1}} + \\beta_1 * Ocean_{y[t,]}$$\n$$logit(\\phi_{foraging}) = \\alpha_{Behavior_{t-1}} + \\beta_2 * Ocean_{y[t,]}$$\n\n```{r,fig.height=3,fig.width=3.5}\ndplot<-function(a1,beta,x){\n  y<-inv.logit(a1[1]+beta[1]*x)\n  d11<-data.frame(x,y,State=\"Traveling\",Begin=\"Traveling\")\n  \n  y<-1-inv.logit(a1[1]+beta[1]*x)\n  d12<-data.frame(x,y,State=\"Feeding\",Begin=\"Traveling\")\n\n  y<-inv.logit(a1[2]+beta[2]*x)\n  d21<-data.frame(x,y,State=\"Traveling\",Begin=\"Feeding\")\n  \n  y<-1-inv.logit(a1[2]+beta[2]*x)\n  d22<-data.frame(x,y,State=\"Feeding\",Begin=\"Feeding\")\n  \n  d<-rbind_all(list(d11,d12,d21,d22))\n}\n```\n\n\n##Continious tracks\n\nThe transmitter will often go dark for 10 to 12 hours, due to weather, right in the middle of an otherwise good track. The model requires regular intervals to estimate the turning angles and temporal autocorrelation. As a track hits one of these walls, call it the end of a track, and begin a new track once the weather improves. We can remove any micro-tracks that are less than three days.\nSpecify a duration, calculate the number of tracks and the number of removed points. Iteratively.\n\n```{r}\n\n##Time is the beginning of the first point.\nstep_length=6\n\nsxy<-split(mxy,mxy$Animal)\n\n#time diff function\ntimed<-function(d,step_length){\n  d$j[1]<-0\n  for (x in 2:nrow(d)){\n    d$j[x]<-as.numeric(difftime(as.POSIXct(d$timestamp[x]),as.POSIXct(d$timestamp[x-1]),units=\"mins\"))/(step_length*60)\n  }\n  \n  #Split out track endings\n  ends<-c(1,which(d$j>1),nrow(d))\n\n  for(w in 2:length(ends)){\n    d[ends[w-1]:ends[w],\"Track\"]<-w-1\n  }\n  \n  #remove tracks that are shorter than three days\n  track_time<-d %>% group_by(Track) %>% summarize(mt=difftime(max(as.POSIXct(timestamp)),min(as.POSIXct(timestamp)),units=\"days\")) %>% filter(mt>=2) %>% .$Track\n\n  \n  d<-d[d$Track %in% track_time,]\n  \n  #renumber the tracks\n  d$Track<-as.numeric(as.factor(d$Track))\n  return(d)\n  }\n\nsxy<-lapply(sxy,timed,step_length=6)\n\n#Format matrices for jags\nmxy<-rbind_all(sxy)\n\n######recode whales\nmxy$Animal<-as.numeric(as.factor(mxy$Animal))\n\nsxy<-split(mxy,list(mxy$Animal,mxy$Track),drop=TRUE)\n\nsxy<-lapply(sxy,function(x){\n#How many observations in each step length segment\nx$Step<-as.numeric(cut(as.POSIXct(x$timestamp),\"6 hours\"))\nreturn(x)\n})\n\nmxy<-rbind_all(sxy)\n```\n\n```{r}\n#total number of steps per track/animal\nsteps_all<-mxy %>% group_by(Animal,Track) %>% summarize(n=length(unique(Step)))\n\n# give each step a label\nmxy<-mxy %>% group_by(Animal,Track,Step) %>% mutate(jStep=1:n())\n\n#Cast time array\nj<-acast(mxy,Animal~Track~Step~jStep,value.var=\"j\")\n\n#how many observations per individual in each Step\nmxy$Step<-factor(mxy$Step,levels=1:max(steps_all$n))\nidx<-melt(table(mxy$Animal,mxy$Track,mxy$Step))\ncolnames(idx)<-c(\"Animal\",\"Track\",\"Step\",\"jStep\")\nidx<-acast(data=idx,Animal~Track~Step)\n\n#make ocean a matrix -> MEAN VALUE -> will this yield a jags error on empty cells?\noc<-acast(mxy,Animal~Track~Step,value.var=\"ocean\",fun.aggregate = mean)\n\n#Individuals\nind=length(unique(mxy$Animal))\n\n#tracks per indivudal\ntracks<-mxy %>% group_by(Animal) %>% summarize(tracks=length(unique(Track))) %>% .$tracks\n\n#steps per track\nsteps<-acast(steps_all,Animal~Track,value.var=\"n\")\n\n#obs array\nobs<-melt(mxy,measure.vars=c(\"x\",\"y\"))\nobs<-acast(obs,Animal~Track~Step~jStep~variable)\n\n```\n\nHow did the filter change the extent of tracks?\n\n```{r}\n#Plot\nmxy<-mxy %>% arrange(Animal,Track,Step,jStep)\n\npp<-c(mean(mxy$x),mean(mxy$y))\nm <- get_map(location=pp,source=\"google\",zoom=4,scale=2,maptype=\"satellite\")\nggmap(m)+geom_path(data=mxy, aes(x=x, y=y,col=as.factor(Animal)),size=.5) + labs(col=\"Whale\")\n```\n\n```{r,fig.height=4,fig.width=6}\nggplot(data=steps_all,aes(x=n*step_length/24)) + geom_histogram() + labs(x=\"Days\") + ggtitle(\"Track Length\")\nggplot(data=steps_all,aes(x=Track)) + geom_histogram() + labs(x=\"Subtracks per Animal\")\n```\n\n\n```{r,comment=NA}\n#source model\nsource(\"Bayesian/MultiSpecies.R\")\nprint.noquote(readLines(\"Bayesian/MultiSpecies.R\"))\n```\n\n```{r,eval=T}\n#prior cov shape\nR <- diag(c(1,1))\ndata=list(argos=obs,steps=steps,R=R,ocean=oc,ind=ind,j=j,idx=idx,tracks=tracks)\n\n#paramters to track\npt<-c(\"theta\",\"gamma\",\"phi\",\"lalpha_mu\",\"lbeta_mu\",\"state\")\n\nif(newModel){\n  system.time(jagM<-jags.parallel(model.file = \"Bayesian/Multi_RW.jags\",data=data,n.chains=2,parameters.to.save=pt,n.iter=4000,n.burnin=2500,n.thin=2,DIC=FALSE))\n}\n\n```\n\n##Chains\n```{r,fig.height=10}\n#bind chains\npc<-melt(jagM$BUGSoutput$sims.array)\ncolnames(pc)<-c(\"Draw\",\"chain\",\"par\",\"value\")\n\n#extract parameter name\npc$parameter<-data.frame(str_match(pc$par,\"(\\\\w+)\"))[,-1]\n\n#Extract index\nsplitpc<-split(pc,pc$parameter)\n\n#single index\nsplitpc[c(\"lalpha_mu\",\"lbeta_mu\",\"gamma\",\"theta\")]<-lapply(splitpc[c(\"lalpha_mu\",\"lbeta_mu\",\"gamma\",\"theta\")],function(x){\n    sv<-data.frame(str_match(x$par,\"(\\\\w+)\\\\[(\\\\d+)]\"))[,3]\n    pc<-data.frame(x,Behavior=sv)\n    return(pc)\n})\n\n#State index\nsplitpc[c(\"state\")]<-lapply(splitpc[c(\"state\")],function(x){\n    #As matrices\n    sv<-data.frame(str_match(x$par,\"(\\\\w+)\\\\[(\\\\d+),(\\\\d+),(\\\\d+)]\"))[,3:5]\n    colnames(sv)<-c(\"Animal\",\"Track\",\"step\")\n    pc<-data.frame(x,sv)\n})\n\n#Three index\nsplitpc[c(\"phi\")]<-lapply(splitpc[c(\"phi\")],function(x){\n#As matrices\n    sv<-data.frame(str_match(x$par,\"(\\\\w+)\\\\[(\\\\d+),(\\\\d+),(\\\\d+),(\\\\d+)]\"))[,3:6]\n    colnames(sv)<-c(\"Animal\",\"Track\",\"step\",\"Behavior\")\n    pc<-data.frame(x,sv)\n})\n\n#bind all matrices back together\npc<-rbind_all(splitpc)\nrm(splitpc)\n\n#plot all but phi and state\nggplot(pc[!pc$parameter %in% c(\"phi\",\"state\"),],aes(x=Draw,y=value)) + facet_wrap(~par,scales=\"free\",ncol=2) + geom_line(aes(col=as.factor(chain))) + labs(col=\"Chain\")\n\n```\n\n```{r,fig.width=11}\n#Plot\nggplot(data=pc[!pc$parameter %in% c(\"phi\",\"state\"),],aes(x=value)) + geom_histogram() + facet_wrap(~par,scales='free',ncol=4) + theme_bw()  + ggtitle(\"Estimated parameters\")\n```\n\n###Compare to priors\n\n```{r}\n#add comparison to priors\ntodraw<-table(pc$par)[1]\npc$Estimate<-\"Posterior\"\n\n#add priors\n#alpha\na1prior<-data.frame(Draw=1:todraw,par='alpha[1]',value=rnorm(todraw,0,1.67),parameter='lalpha_mu',Behavior=1,Estimate=\"Prior\")\n\na2prior<-data.frame(Draw=1:todraw,par='alpha[2]',value=rnorm(todraw,0,1.67),parameter='lalpha_mu',Behavior=2,Estimate=\"Prior\")\n\nbeta1prior<-data.frame(Draw=1:todraw,par='beta[1]',value=rnorm(todraw,0,1.67),parameter='lbeta_mu',Behavior=1,Estimate=\"Prior\")\n\nbeta2prior<-data.frame(Draw=1:todraw,par='beta[2]',value=rnorm(todraw,0,1.67),parameter='lbeta_mu',Behavior=2,Estimate=\"Prior\")\n\ngamma1prior<-data.frame(Draw=1:todraw,par='gamma[1]',value=rbeta(todraw,5,2),parameter='gamma',Behavior=1,Estimate=\"Prior\")\n\ngamma2prior<-data.frame(Draw=1:todraw,par='gamma[2]',value=rbeta(todraw,2,5),parameter='gamma',Behavior=2,Estimate=\"Prior\")\n\nprs<-rbind_all(list(a1prior,a2prior,beta1prior,beta2prior,gamma1prior,gamma2prior))\n\nprs$Behavior<-as.factor(prs$Behavior)\n\nallp<-rbind_all(list(pc[!pc$parameter %in% c(\"phi\"),],prs))\n\nggplot(allp,aes(x=Behavior,y=value,fill=Estimate)) + geom_violin() + facet_wrap(~parameter,scale=\"free\")\nrm(allp)\n```\n\n##Prediction - environmental function\n\n```{r}\n#get the posterior estimates of the env function\npredp<-pc %>% filter(parameter %in% c('lbeta_mu','lalpha_mu')) %>% group_by(par) %>% summarize(mean=mean(value),lower=quantile(value,0.05),upper=quantile(value,0.95)) %>% melt()\n\npredp<-dcast(predp,...~par)\n\npostplot<-list()\nfor(x in 1:nrow(predp)){\n  postplot[[x]]<-dplot(a1=as.numeric(predp[x,c(\"lalpha_mu[1]\",\"lalpha_mu[2]\")]),beta=as.numeric(predp[x,c(\"lbeta_mu[1]\",\"lbeta_mu[2]\")]),x=mxy$ocean)\n}\nnames(postplot)<-predp$variable\n\npostplot<-lapply(postplot,function(x){\n  x$ID<-1:nrow(x)\n  return(x)\n})\npostplot<-melt(postplot,id.vars=colnames(postplot[[1]]))\n\ndsum<-dcast(postplot,ID+x+State+Begin~L1,value.var=\"y\")\n\n#mean env estimate\nggplot(dsum[,]) + geom_ribbon(aes(x=x,y=mean,ymin=upper,ymax=lower,fill=State),alpha=0.5) + theme_bw() + labs(col=\"Transition\",x=\"Ocean Depth (km)\",y=\"Probability\",fill=\"Transition\") + facet_wrap(~Begin) \n```\n\n#Behavioral Prediction\n\n```{r}\n#We just need Feeding behavior\nbehav_chains<-pc[pc$Behavior == 2 & pc$parameter %in% \"phi\",]\n\n#arrange by time - capitalize\nbehav_chains$Step<-as.numeric(as.character(behav_chains$step))\nbehav_chains<-behav_chains %>% arrange(Step)\n\n#Label Behaviors\nbehav_chains$Behavior<-as.factor(behav_chains$Behavior)\nlevels(behav_chains$Behavior)<-c(\"Traveling\",\"Feeding\")\n\n#average phi\nmean_phi<-behav_chains %>% group_by(Animal,Track,Step) %>% summarize(phi=mean(value))\n\nmxy<-merge(mxy,mean_phi,by=c(\"Step\",\"Track\",\"Animal\"))\n\n#ensure order for plotting\nmxy<-mxy %>% arrange(Animal,Track,Step,jStep)\n\nrm(behav_chains)\n```\n\n##Spatial Prediction\n\n### Per Animal\n```{r}\nsxy<-split(mxy,mxy$Animal)\nspp<-lapply(sxy,function(x){\n  pp<-bbox(cbind(x$x,x$y))\n  m <- get_map(location=pp,zoom=4,source=\"google\",scale=2,maptype=\"satellite\")\n  ggmap(m)+geom_path(data=x, aes(x=x, y=y,col=phi),size=.5)   + scale_color_continuous(low='blue',high='red',limits=c(0,1)) + labs(col=\"Probability of Feeding\") + facet_wrap(~Animal) + theme_bw()\n})\nspp\n\n```\n\n\n### Per Track\n```{r,fig.height=10,fig.width=12}\nsxy<-split(mxy,list(mxy$Animal,mxy$Track),drop=T)\nspp<-lapply(sxy,function(x){\n  pp<-bbox(cbind(x$x,x$y))\n  m <- get_map(location=pp,source=\"google\",zoom=6,scale=2,maptype=\"satellite\")\n  ggmap(m)+geom_path(data=x, aes(x=x, y=y,col=phi),size=.5)   + scale_color_continuous(limits=c(0,1),low='blue',high='red') + labs(col=\"Probability of Feeding\") + facet_wrap(~Track) + theme_bw()\n})\nspp\n```\n\n##Log Odds of Feeding\n```{r}\n#phi and ocean plot\nggplot(data=mxy,aes(x=ocean,y=logit(phi))) + geom_point() + labs(x=\"Ocean Depth\",y=\"Estimated Log Odds of Feeding\") + facet_wrap(~Animal)\n```\n\n##Autocorrelation in behavior\n\n```{r,fig.height=10}\n#create proper time stamp\nggplot(data=mxy,aes(x=as.POSIXct(timestamp),y=phi,col=ocean)) + geom_line(aes(group=Animal),size=2.5) + labs(\"Probability of Feeding\") + theme_bw() + scale_color_continuous(low='light blue',high='black') + labs(x=\"Time\",y=\"Liklihood of Feeding\") + facet_wrap(~Animal,ncol=2,scales=\"free\") + ylim(0,1)\n```\n\n##Behavioral description\n\n## Predicted behavior duration\n```{r}\nrunf<-function(x){\n  #arrange by step\n  #calculate run length\n  state_change<-rle(as.numeric(x$value))\n  runl<-data.frame(Animal=unique(x$Animal),runs=state_change$lengths,Behavior=state_change$values)\n  runl$Behavior<-as.factor(runl$Behavior)\n  levels(runl$Behavior)<-c(\"Traveling\",\"Feeding\")\n  \n  return(runl)\n}\n\nruns<-pc %>% filter(parameter=='state') %>% group_by(Animal,Draw,chain) %>% do(runf(.))\n\n\n#turn steps to hours\nruns$hours<-runs$runs*step_length\nggplot(runs,aes(x=as.numeric(hours),fill=Behavior)) + geom_histogram(position='dodge') + scale_x_continuous(breaks=seq(0,max(runs$hours),by=48)) + labs(x=\"Hours\") + ggtitle(\"Predicted Behavior Duration\") + theme_bw()\n```\n\n```{r,fig.height=3,fig.with=3.5}\nmr<-runs %>% group_by(Behavior) %>% summarize(mean=mean(hours),lower=quantile(runs,0.05),upper=quantile(runs,0.95))\nggplot(mr,aes(x=Behavior,y=mean,ymin=lower,ymax=upper)) + geom_pointrange(size=2) + theme_bw() + ggtitle(\"Average Duration of Behavior\") + labs(y=\"Hours\")\n```\n\n##Location of Behavior\n\n```{r}\nmsp<-SpatialPointsDataFrame(cbind(mxy$x,mxy$y),data=mxy[,c(\"x\",\"y\",\"Animal\",\"phi\",\"timestamp\")],proj=CRS(\"+proj=longlat +datum=WGS84\"))\n\nr<-raster(msp)\nres(r)<-1\n\nm<-rasterize(x=msp,y=r,field=\"phi\")\n\n```\n\nGlobal Plotting\n\n```{r}\n#plotting\nfeedmap <- data.frame(rasterToPoints(m))\n\ntemp <- get_map(location=bbox(m),source=\"google\",zoom=3,maptype=\"satellite\")\n\nggmap(temp) + labs(fill=\"Probabilty of Feeding\")+ geom_tile(data=feedmap,aes(x=x, y=y,fill=layer),alpha=0.9) + theme_minimal() + scale_color_discrete(guide=\"none\") + scale_fill_continuous(low=\"blue\",high=\"red\")\n```\n\nJust the West Antarctic Penisula\n\n```{r}\nmsp<-SpatialPointsDataFrame(cbind(mxy$x,mxy$y),data=mxy[,c(\"x\",\"y\",\"Animal\",\"phi\",\"timestamp\")],proj=CRS(\"+proj=longlat +datum=WGS84\"))\n\nr<-raster(msp,ext=extent(c(-70,-55,-66,-58)))\nres(r)<-0.5\n\nm<-rasterize(x=msp,y=r,field=\"phi\")\n\n#plotting\nfeedmap <- data.frame(rasterToPoints(m))\n\ntemp <- get_map(location=bbox(m),source=\"google\",zoom=5,maptype=\"satellite\")\n\nggmap(temp) + labs(fill=\"Probabilty of Feeding\")+ geom_tile(data=feedmap,aes(x=x, y=y,fill=layer),alpha=0.8) + theme_minimal() + scale_color_discrete(guide=\"none\") + scale_fill_continuous(low=\"blue\",high=\"red\")\n```\n\n###Proportional Hazards\n\nTODO: NEEDS TO ACCOUNT FOR CENSORED DATA! \n\nSurvival analysis typically examines the relationship between time to death as a function of covariates. From this we can get the instantaneous rate of death at time t f(t), which is the cumulative distribution of the likelihood of death.\n\nLet T represent survival time.\n\n$$ P(t) = Pr(T<t)$$ \nwith a pdf\n$$p(t) = \\frac{dP(t)}{dt}$$\n\nThe instantaneous risk of death at time t (h(t)), conditional on survival to that time:\n\n$$ h(t) = \\lim{\\Delta_t\\to 0} \\frac{Pr[(t<T<t + \\Delta_t)]|T>t}{\\Delta t}$$\n\nwith covariates:\n$$log (h_i(t)) = \\alpha + \\beta_i *x$$\n\nThe cox model has no intercept, making it semi-parametric\n$$ log(h_i(t)) = h_0(t) + \\beta_1 * x$$\n\n```{r,eval=F}\n\n\nrunf<-function(x){\n  #arrange by step\n  #calculate run length\n  state_change<-rle(as.numeric(x$value))\n  runl<-data.frame(Animal=unique(x$Animal),runs=state_change$lengths,Behavior=state_change$values)\n  runl$Behavior<-as.factor(runl$Behavior)\n  levels(runl$Behavior)<-c(\"Traveling\",\"Feeding\")\n  x[cumsum(runl$runs)+1,\"Bout\"]<-seq(1,nrow(runl),1)\n  return(runl)\n}\n\nstatec<-pc %>% filter(parameter=='state') %>% group_by(Animal,Draw,chain) %>% mutate(runf(.))\n\n\n#Create a 'bout' encoding for every time it changes\nstatec[cumsum(runs$hours)+1,\"Bout\"]<-seq(1,nrow(runs),1)\n\n#Fill missing NA values\nrepeat.before = function(x) {   # repeats the last non NA value. Keeps leading NA\n    ind = which(!is.na(x))      # get positions of nonmissing values\n    if(is.na(x[1]))             # if it begins with a missing, add the \n          ind = c(1,ind)        # first position to the indices\n    rep(x[ind], times = diff(   # repeat the values at these indices\n       c(ind, length(x) + 1) )) # diffing the indices + length yields how often \n}                               \n\nstatec$Bout<-repeat.before(statec$Bout)\n\nfeedr<-runs[runs$Behavior %in% \"Feeding\",]\n\n#Every run eventually ends in a switch (that's what makes it a run)\nfeedr$status<-1\n\n#survival analysis\ntf<-coxph(Surv(time=feedr$hours,event=feedr$status)~feedr$Animal)\nsummary(tf)\nplot(survfit(tf),ylab=\"Proportion still feeding\",xlab=\"Duration (hours)\")\n```\n\n```{r}\n#notify end of run\n#size of the run\ngc()\nsave.image(\"SingleSpecies.RData\")\n```\n",
    "created" : 1466525231659.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "118921480",
    "id" : "25DC02B9",
    "lastKnownWriteTime" : 1466528012,
    "path" : "~/Whales/SingleSpecies.Rmd",
    "project_path" : "SingleSpecies.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}