{
    "contents" : "---\ntitle: \"Antarctic Whale Project: Single Species\"\nauthor: \"Ben Weinstein\"\ndate: \"`r Sys.time()`\"\noutput: \n  html_document:\n    keep_md: true\n    number_sections: true\n    toc: true\n    theme: spacelab\n---\n\n```{r,warning=FALSE,message=FALSE,echo=FALSE}\nlibrary(knitr)\nopts_chunk$set(echo=F,warning=F,message=F,fig.width = 11,fig.height = 5)\nlibrary(boot)\nlibrary(raster)\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(survival)\nlibrary(MASS)\nlibrary(ggmap)\nlibrary(dplyr)\nlibrary(chron)\nlibrary(gridExtra)\nlibrary(stringr)\nlibrary(R2jags)\nlibrary(move)\n\n#New model to be run, flag turned off if just updating.\nnewModel<-T\n```\n\n```{r,eval=F}\n#Load in data\nload(\"SingleSpecies.RData\")\n#jags$recompile()\nnewModel<-F\n```\n\n#Abstract\n```{r}\n\n#raster layers\n#ice\nice<-raster(\"InputData/ETOPO1_Ice_g_geotiff.tif\")\nice<-round(ice*-1/1000,3)\nrice<-aggregate(ice,fact=0.1/res(ice))\n\n#coast\ndistc<-raster(\"InputData/DistancetoCoast.tif\")\nrice[rice<0]<-NA\ndistc[is.na(rice)]<-NA\n\n#read data\nmdat<-read.csv(\"InputData/Antarctic Humpback overlap with krill fisheries -1133643618235885002.csv\")\n\n##need to look into making into a movebank object.\n\n#name env columns\n#Create a oceandepth in km \nmdat$ocean<-round(mdat$ETOPO1.Elevation * -1 /1000,3)\nmdat$coast<-round(mdat$NASA.Distance.to.Coast,1)\nmdat$SST<-mdat$MODIS.Ocean.Aqua.OceanColor.4km.Monthly.Daytime.SST\nmdat$ChloroA<-mdat$MODIS.Ocean.Aqua.OceanColor.4km.Monthly.Chlorophyll.A\n\n#standardize column names to match the simulation\n#Create an animal tag.\nmxy <- as(mdat, \"data.frame\")\nmxy$Animal<-mxy$individual.local.identifier\nmxy$x<-mxy$location.long\nmxy$y<-mxy$location.lat\n\n#grab set of animals\nmxy<-mxy[mxy$Animal %in% c(\"112699\",\"121207\",\"131151\",\"112703\",\"121211\",\"131132\",\"112737\",\"131156\",\"12326\",\"123232\",\"112705\",\"154187\",\"121210\",\"131134\",\"131141\",\"112701\",\"131159\",\"131142\",\"131144\",\"154186\",\"123224\"),]\n\n#mxy<-mxy[mxy$Animal %in% c(\"131144\",\"154186\",\"123224\",\"131132\",\"112737\",\"131156\",\"131134\",\"131141\"),]\nmxy$Animal<-as.numeric(as.factor(mxy$Animal))\n\n#empty coordinates\nmxy<-mxy[!is.na(mxy$x),]\n\n#crop by extent\nd<-SpatialPointsDataFrame(cbind(mxy$x,mxy$y),data=mxy)\nd<-crop(d,y=extent(c(-70,-55,-66,-58)))\nmxy<-as.data.frame(d)\n\n#set datestamp\nmxy$timestamp<-as.POSIXct(mxy$timestamp,format=\"%Y-%m-%d %H:%M:%S.000\")\n\n#remove empty timestamps\nmxy<-mxy[!is.na(mxy$timestamp),]\n\n#remove duplicates\nmxy<-mxy[!duplicated(data.frame(mxy$timestamp,mxy$Animal)),]\n```\n\n#Descriptive Statistics\n```{r}\n#no distance to coast,elevation\nmxy<-mxy[!mxy$ETOPO1.Elevation>0,]\n```\n\n```{r}\n#hold copy of orig\noxy<-mxy\n\n#Plot\npp<-c(mean(mxy$x),mean(mxy$y))\nm <- get_map(location=pp,source=\"google\",zoom=5,scale=2,maptype=\"satellite\",color = \"bw\")\nggmap(m)+geom_path(data=mxy, aes(x=x, y=y,col=as.factor(Animal)),size=.5) + scale_color_discrete(guide=\"none\") + theme_inset()\n```\n\n##Distance\n\n```{r,fig.height=3}\nmoved<-move(x=mxy$x,y=mxy$y,time=as.POSIXct(mxy$timestamp),proj=CRS(\"+proj=longlat +ellps=WGS84\"),animal=mxy$Animal,data=as.data.frame(mxy),sensor=mxy$Animal,removeDuplicatedTimestamps=T)\ndstat<-melt(move::distanceSummary(moved))\n\ndstat<-droplevels(dstat[dstat$variable %in% c(\"TravDist\",\"AverDist\",\"FarthDist\"),])\nlevels(dstat$variable)<-c(\"Total Distance\",\"Average Distance Between Points\",\"Farthest Distance Between Points\")\nggplot(dstat,aes(value/1000)) + geom_histogram() + facet_wrap(~variable,scales=\"free\") + labs(x=\"Kilometers\")\n```\n\n##Time \n```{r,fig.height=3}\ntstat<-move::timeSummary(moved)\ntstat<-melt(tstat,measure.vars=colnames(tstat[[1]]))\ntstat<-droplevels(tstat[tstat$variable %in% c(\"Duration\",\"AverDur\"),])\nlevels(tstat$variable)<-c(\"Total Time (Hours)\",\"Average Time Between Points (Hours)\")\nggplot(tstat,aes(value)) + geom_histogram() + facet_wrap(~variable,scales=\"free\")\n```\n\n##Velocity\n```{r,fig.height=3}\nvstat<-move::speedSummary(moved)\nvstat<-melt(vstat,measure.vars=colnames(vstat[[1]]))\nlevels(vstat$variable)<-c(\"Average Speed (m/s)\",\"Variance in Speed (m/s)\",\"Max Speed (m/s)\")\nggplot(vstat,aes(value)) + geom_histogram() + facet_wrap(~variable,scales=\"free\")\n```\n\n##Angles\n\n```{r,fig.height=2}\nastat<-move::angleSummary(moved)\nastat<-melt(astat,measure.vars=colnames(astat[[1]]))\nastat<-droplevels(astat[astat$variable %in% \"AverAzimuth\",])\nlevels(astat$variable)<-\"Turning Angle (degrees)\"\nggplot(astat,aes(value)) + geom_histogram() + facet_wrap(~variable,scales=\"free\")\n```\n\n#Correlated random walk\n\n*Process Model*\n\n$$ d_{t} \\sim T*d_{t-1} + Normal(0,\\Sigma)$$\n$$ x_t = x_{t-1} + d_{t} $$\n\n## Parameters\n\nFor each individual:\n\n$$\\theta = \\text{Mean turning angle}$$\n$$\\gamma = \\text{Move persistence} $$\n\nFor both behaviors process variance is:\n$$ \\sigma_{latitude} = 0.1$$\n$$ \\sigma_{longitude} = 0.1$$\n\n##Behavioral States\n\n$$ \\text{For each individual i}$$\n$$ Behavior_1 = \\text{traveling}$$\n$$ Behavior_2 = \\text{foraging}$$\n\n$$ \\alpha_{i,1,1} = \\text{Probability of remaining traveling when traveling}$$\n$$\\alpha_{i,2,1} = \\text{Probability of switching from feeding to traveling}$$\n\n$$\\begin{matrix}\n  \\alpha_{i,1,1} & 1-\\alpha_{i,1,1} \\\\\n  \\alpha_{i,2,1} & 1-\\alpha_{i,2,1} \\\\\n\\end{matrix}\n$$\n\n##Environment\n\nBehavioral states are a function of local environmental conditions. The first environmental condition is ocean depth. I then build a function for preferential foraging in shallow waters.\n\nIt generally follows the form, conditional on behavior at t -1:\n\n$$Behavior_t \\sim Multinomial([\\phi_{traveling},\\phi_{foraging}])$$\n$$logit(\\phi_{traveling}) = \\alpha_{Behavior_{t-1}} + \\beta_1 * Ocean_{y[t,]}$$\n$$logit(\\phi_{foraging}) = \\alpha_{Behavior_{t-1}} + \\beta_2 * Ocean_{y[t,]}$$\n\n```{r,fig.height=3,fig.width=3.5}\ndplot<-function(a1,beta,beta2=0,x,coast=0){\n  y<-inv.logit(a1[1]+beta[1]*x + beta2*coast)\n  d11<-data.frame(x,y,State=\"Traveling\",Begin=\"Traveling\")\n  \n  y<-1-inv.logit(a1[1]+beta[1]*x+ beta2*coast)\n  d12<-data.frame(x,y,State=\"Feeding\",Begin=\"Traveling\")\n\n  y<-inv.logit(a1[2]+beta[2]*x+ beta2*coast)\n  d21<-data.frame(x,y,State=\"Traveling\",Begin=\"Feeding\")\n  \n  y<-1-inv.logit(a1[2]+beta[2]*x+ beta2*coast)\n  d22<-data.frame(x,y,State=\"Feeding\",Begin=\"Feeding\")\n  \n  d<-rbind_all(list(d11,d12,d21,d22))\n}\n```\n\n##Continious tracks\n\nThe transmitter will often go dark for 10 to 12 hours, due to weather, right in the middle of an otherwise good track. The model requires regular intervals to estimate the turning angles and temporal autocorrelation. As a track hits one of these walls, call it the end of a track, and begin a new track once the weather improves. We can remove any micro-tracks that are less than three days.\nSpecify a duration, calculate the number of tracks and the number of removed points. Iteratively.\n\n```{r}\n##Time is the beginning of the first point.\nstep_length=4\n\nsxy<-split(mxy,mxy$Animal)\n\n#time diff function\ntimed<-function(d,step_length){\n  d$j[1]<-0\n  for (x in 2:nrow(d)){\n    d$j[x]<-as.numeric(difftime(as.POSIXct(d$timestamp[x]),as.POSIXct(d$timestamp[x-1]),units=\"mins\"))/(step_length*60)\n  }\n  \n  #Split out track endings\n  ends<-c(1,which(d$j>1),nrow(d))\n\n  for(w in 2:length(ends)){\n    d[ends[w-1]:ends[w],\"Track\"]<-w-1\n  }\n  \n  #remove tracks that are shorter than three days\n  track_time<-d %>% group_by(Track) %>% summarize(mt=difftime(max(as.POSIXct(timestamp)),min(as.POSIXct(timestamp)),units=\"hours\")) %>% filter(mt>=8) %>% .$Track\n  \n  d<-d[d$Track %in% track_time,]\n  \n  #renumber the tracks\n  d$Track<-as.numeric(as.factor(d$Track))\n  return(d)\n  }\n\nsxy<-lapply(sxy,timed,step_length=4)\n\n#Format matrices for jags\nmxy<-rbind_all(sxy)\n\n######recode whales\n#mxy$Animal<-as.numeric(as.factor(mxy$Animal))\n\nsxy<-split(mxy,list(mxy$Animal,mxy$Track),drop=TRUE)\n\nsxy<-lapply(sxy,function(x){\n#How many observations in each step length segment\nx$Step<-as.numeric(cut(as.POSIXct(x$timestamp),\"4 hours\"))\nreturn(x)\n})\n\nmxy<-rbind_all(sxy)\n```\n\n```{r}\n#total number of steps per track/animal\nsteps_all<-mxy %>% group_by(Animal,Track) %>% summarize(n=length(unique(Step)))\n\n# give each step a label\nmxy<-mxy %>% group_by(Animal,Track,Step) %>% mutate(jStep=1:n())\n\n#Cast time array\nj<-acast(mxy,Animal~Track~Step~jStep,value.var=\"j\")\n\n#how many observations per individual in each Step\nmxy$Step<-factor(mxy$Step,levels=1:max(steps_all$n))\nidx<-melt(table(mxy$Animal,mxy$Track,mxy$Step))\ncolnames(idx)<-c(\"Animal\",\"Track\",\"Step\",\"jStep\")\nidx<-acast(data=idx,Animal~Track~Step)\n\n#make ocean a matrix -> MEAN VALUE -> will this yield a jags error on empty cells?\noc<-acast(mxy,Animal~Track~Step,value.var=\"ocean\",fun.aggregate = mean)\n\n#make coast a matrix -> MEAN VALUE -> will this yield a jags error on empty cells?\ncoast<-acast(mxy,Animal~Track~Step,value.var=\"coast\",fun.aggregate = mean)\n\n#Individuals\nind=length(unique(mxy$Animal))\n\n#tracks per indivudal\ntracks<-mxy %>% group_by(Animal) %>% summarize(tracks=length(unique(Track))) %>% .$tracks\n\n#steps per track\nsteps<-acast(steps_all,Animal~Track,value.var=\"n\")\n\n#obs array\nobs<-melt(mxy,measure.vars=c(\"x\",\"y\"))\nobs<-acast(obs,Animal~Track~Step~jStep~variable)\n\n```\n\nHow did the filter change the extent of tracks?\n\n```{r}\n#Plot\nmxy<-mxy %>% arrange(Animal,Track,Step,jStep)\n\npp<-c(mean(mxy$x),mean(mxy$y))\nm <- get_map(location=pp,source=\"google\",zoom=5,scale=2,maptype=\"satellite\",color = \"bw\")\nggmap(m)+geom_path(data=mxy, aes(x=x, y=y,col=as.factor(Animal)),size=.5) + scale_color_discrete(guide=\"none\") + theme_inset()\n```\n\n```{r,fig.height=15}\nggplot() +  geom_path(data=oxy,col='blue',aes(x=x,y=y)) +  geom_path(data=mxy,col='red',aes(x=x,y=y),size=2,alpha=0.7)  + facet_wrap(~Animal,scales=\"free\",ncol=4)\n```\n\n```{r,fig.height=3,fig.width=5}\nggplot(data=steps_all,aes(x=n*step_length/24)) + geom_histogram() + labs(x=\"Days\") + ggtitle(\"Track Length\")\nggplot(data=steps_all,aes(x=Track)) + geom_histogram() + labs(x=\"Subtracks per Animal\")\n```\n\n```{r,child=\"Bayesian/MultiSpecies.R\",eval=F}\n```\n\n```{r,eval=T}\n#source jags file\nsource(\"Bayesian/MultiSpecies.R\")\n\n#prior cov shape\nR <- diag(c(1,1))\ndata=list(argos=obs,steps=steps,R=R,ocean=oc,coast=coast,ind=ind,j=j,idx=idx,tracks=tracks)\n\n#paramters to track\npt<-c(\"theta\",\"gamma\",\"phi\",\"alpha_mu\",\"beta_mu\",\"beta2_mu\",\"state\")\n\nif(newModel){\n  system.time(jagM<-jags.parallel(model.file = \"Bayesian/Multi_RW.jags\",data=data,n.chains=2,parameters.to.save=pt,n.iter=2000,n.burnin=1000,n.thin=4,DIC=FALSE))\n}\n\n#save.image(\"SingleSpecies.RData\")\n\n```\n\n##Chains\n```{r,fig.height=10}\n#bind chains\npc<-melt(jagM$BUGSoutput$sims.array)\ncolnames(pc)<-c(\"Draw\",\"chain\",\"par\",\"value\")\n\n#extract parameter name\npc$parameter<-data.frame(str_match(pc$par,\"(\\\\w+)\"))[,-1]\n\n#Extract index\nsplitpc<-split(pc,pc$parameter)\n\n#single index\nsplitpc[c(\"alpha_mu\",\"beta_mu\",\"beta2_mu\",\"gamma\",\"theta\")]<-lapply(splitpc[c(\"alpha_mu\",\"beta_mu\",\"beta2_mu\",\"gamma\",\"theta\")],function(x){\n    sv<-data.frame(str_match(x$par,\"(\\\\w+)\\\\[(\\\\d+)]\"))[,3]\n    pc<-data.frame(x,Behavior=sv)\n    return(pc)\n})\n\n#State index\nsplitpc[c(\"state\")]<-lapply(splitpc[c(\"state\")],function(x){\n    #As matrices\n    sv<-data.frame(str_match(x$par,\"(\\\\w+)\\\\[(\\\\d+),(\\\\d+),(\\\\d+)]\"))[,3:5]\n    colnames(sv)<-c(\"Animal\",\"Track\",\"step\")\n    pc<-data.frame(x,sv)\n})\n\n#Three index\nsplitpc[c(\"phi\")]<-lapply(splitpc[c(\"phi\")],function(x){\n#As matrices\n    sv<-data.frame(str_match(x$par,\"(\\\\w+)\\\\[(\\\\d+),(\\\\d+),(\\\\d+),(\\\\d+)]\"))[,3:6]\n    colnames(sv)<-c(\"Animal\",\"Track\",\"step\",\"Behavior\")\n    pc<-data.frame(x,sv)\n})\n\n#bind all matrices back together\npc<-rbind_all(splitpc)\nrm(splitpc)\n\n#plot all but phi and state\nggplot(pc[!pc$parameter %in% c(\"phi\",\"state\"),],aes(x=Draw,y=value)) + facet_wrap(~par,scales=\"free\",ncol=2) + geom_line(aes(col=as.factor(chain))) + labs(col=\"Chain\")\n\n```\n\n```{r,fig.width=11}\n#Plot\nggplot(data=pc[!pc$parameter %in% c(\"phi\",\"state\"),],aes(x=value)) + geom_histogram() + facet_wrap(~par,scales='free',ncol=4) + theme_bw()  + ggtitle(\"Estimated parameters\")\n```\n\n###Compare to priors\n\n```{r}\n#add comparison to priors\ntodraw<-table(pc$par)[1]\npc$Estimate<-\"Posterior\"\n\n#add priors\n#alpha\na1prior<-data.frame(Draw=1:todraw,par='alpha[1]',value=rnorm(todraw,0,1.67),parameter='alpha_mu',Behavior=1,Estimate=\"Prior\")\n\na2prior<-data.frame(Draw=1:todraw,par='alpha[2]',value=rnorm(todraw,0,1.67),parameter='alpha_mu',Behavior=2,Estimate=\"Prior\")\n\nbeta1prior<-data.frame(Draw=1:todraw,par='beta[1]',value=rnorm(todraw,0,1.67),parameter='beta_mu',Behavior=1,Estimate=\"Prior\")\n\nbeta2prior<-data.frame(Draw=1:todraw,par='beta[2]',value=rnorm(todraw,0,1.67),parameter='beta_mu',Behavior=2,Estimate=\"Prior\")\n\nbeta21prior<-data.frame(Draw=1:todraw,par='beta2[1]',value=rnorm(todraw,0,1.67),parameter='beta2_mu',Behavior=1,Estimate=\"Prior\")\n\nbeta22prior<-data.frame(Draw=1:todraw,par='beta2[2]',value=rnorm(todraw,0,1.67),parameter='beta2_mu',Behavior=2,Estimate=\"Prior\")\n\ngamma1prior<-data.frame(Draw=1:todraw,par='gamma[1]',value=runif(todraw,0.5,1),parameter='gamma',Behavior=1,Estimate=\"Prior\")\n\ngamma2prior<-data.frame(Draw=1:todraw,par='gamma[2]',value=runif(todraw,0,0.5),parameter='gamma',Behavior=2,Estimate=\"Prior\")\n\nprs<-rbind_all(list(a1prior,a2prior,beta1prior,beta2prior,beta21prior,beta22prior,gamma1prior,gamma2prior))\n\nprs$Behavior<-as.factor(prs$Behavior)\n\nallp<-rbind_all(list(pc[!pc$parameter %in% c(\"phi\",\"state\"),],prs))\n\nggplot(allp,aes(x=Behavior,y=value,fill=Estimate)) + geom_violin() + facet_wrap(~parameter,scale=\"free\")\nrm(allp)\n```\n\n## Parameter Summary\n```{r}\npsum<-pc %>% filter(!parameter %in% c(\"phi\",\"state\")) %>% group_by(parameter,par) %>% summarize(mean=mean(value),lower=quantile(value,0.05),upper=quantile(value,0.95))\n\npsum\nggplot(psum,aes(x=par,y=mean,ymax=upper,ymin=lower)) + geom_linerange() + geom_point() + facet_wrap(~parameter,scales=\"free\")\n```\n\n##Behavior and environment\n\n### Ocean Depth\n```{r}\n#get the posterior estimates of the env function\n\npostplot<-pc %>% filter(parameter %in% c('beta_mu','alpha_mu')) %>% dcast(.,Draw+chain~par) %>% group_by(Draw,chain) %>% do(dplot(a1=c(.$'alpha_mu[1]',.$'alpha_mu[2]'),beta=c(.$'beta_mu[1]',.$'beta_mu[2]'),x=unique(mxy$ocean))) %>% group_by(x=x,Begin,State) %>% summarize(mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))\n\nggplot(postplot) + geom_ribbon(aes(x=x,y=mean,ymin=upper,ymax=lower,fill=State),alpha=0.5) + theme_bw() + labs(col=\"Transition\",x=\"Ocean Depth (km)\",y=\"Probability\",fill=\"Transition\") + facet_wrap(~Begin) + xlim(0,quantile(mxy$ocean,0.5))\n\n#mean env estimate\nggplot(postplot) + geom_ribbon(aes(x=x,y=mean,ymin=upper,ymax=lower,fill=State),alpha=0.5) + theme_bw() + labs(col=\"Transition\",x=\"Ocean Depth (km)\",y=\"Probability\",fill=\"Transition\") + facet_wrap(~Begin) + xlim(0,quantile(mxy$ocean,0.98))\n```\n\n### Distance to Coast\n```{r}\n#get the posterior estimates of the env function\n\npostplot<-pc %>% filter(parameter %in% c('beta2_mu','alpha_mu')) %>% dcast(.,Draw+chain~par) %>% group_by(Draw,chain) %>% do(dplot(a1=c(.$'alpha_mu[1]',.$'alpha_mu[2]'),beta=c(.$'beta2_mu[1]',.$'beta2_mu[2]'),x=unique(mxy$coast))) %>% group_by(x=x,Begin,State) %>% summarize(mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))\n\n#mean env estimate\nggplot(postplot) + geom_ribbon(aes(x=x,y=mean,ymin=upper,ymax=lower,fill=State),alpha=0.5) + theme_bw() + labs(col=\"Transition\",x=\"Distance to Coast (km)\",y=\"Probability\",fill=\"Transition\") + facet_wrap(~Begin) + xlim(0,quantile(mxy$coast,0.5))\n\nggplot(postplot) + geom_ribbon(aes(x=x,y=mean,ymin=upper,ymax=lower,fill=State),alpha=0.5) + theme_bw() + labs(col=\"Transition\",x=\"Distance to Coast (km)\",y=\"Probability\",fill=\"Transition\") + facet_wrap(~Begin) \n\n```\n\n#Behavioral Prediction\n\n```{r}\n#We just need Feeding behavior\nbehav_chains<-pc[pc$Behavior == 2 & pc$parameter %in% \"phi\",]\n\n#arrange by time - capitalize\nbehav_chains$Step<-as.numeric(as.character(behav_chains$step))\nbehav_chains<-behav_chains %>% arrange(Step)\n\n#Label Behaviors\nbehav_chains$Behavior<-as.factor(behav_chains$Behavior)\nlevels(behav_chains$Behavior)<-c(\"Traveling\",\"Feeding\")\n\n#average phi\nmean_phi<-behav_chains %>% group_by(Animal,Track,Step) %>% summarize(phi=mean(value))\n\nmxy<-merge(mxy,mean_phi,by=c(\"Step\",\"Track\",\"Animal\"))\n\n#ensure order for plotting\nmxy<-mxy %>% arrange(Animal,Track,Step,jStep)\n\nrm(behav_chains)\n```\n\n##Spatial Prediction\n\n### Per Animal\n```{r}\nsxy<-split(mxy,mxy$Animal)\nspp<-lapply(sxy,function(x){\n  pp<-bbox(cbind(x$x,x$y))\n  m <- get_map(location=pp,zoom=6,source=\"google\",scale=2,maptype=\"satellite\",color=\"bw\")\n  ggmap(m)+geom_path(data=x, aes(x=x, y=y,col=phi),size=.5)   + scale_color_continuous(low='blue',high='red',limits=c(0,1)) + labs(col=\"Probability of Feeding\") + facet_wrap(~Animal) + theme_inset()\n})\nspp\n\n```\n\n##Log Odds of Feeding\n\n### Ocean Depth\n\n```{r,fig.height=10}\n#phi and ocean plot\nggplot(data=mxy,aes(x=ocean,y=logit(phi))) + geom_point() + labs(x=\"Ocean Depth\",y=\"Estimated Log Odds of Feeding\") + facet_wrap(~Animal,ncol=4,scales=\"free\")\n```\n\n### Distance From Coast\n\n```{r,fig.height=10}\n#phi and ocean plot\nggplot(data=mxy,aes(x=coast,y=logit(phi))) + geom_point() + labs(x=\"Distance to coast\",y=\"Estimated Log Odds of Feeding\") + facet_wrap(~Animal,ncol=4,scales=\"free\")\n```\n\n###Interaction\n\nNo estimate of uncertainty.\n```{r}\ncoastx<-seq(0,quantile(mxy$coast,0.98),quantile(mxy$coast,0.98)/20)\noceanx<-seq(0,quantile(mxy$ocean,0.98),quantile(mxy$ocean,0.98)/20)\nallx<-expand.grid(coastx,oceanx)\ncolnames(allx)<-c(\"coast\",\"ocean\")\nallx$ID<-1:nrow(allx)\nallx$alpha<-filter(pc,par %in% 'alpha_mu[1]') %>% group_by(parameter) %>% summarize(m=mean(value)) %>% .$m\nallx$beta1<-filter(pc,par %in% 'beta_mu[1]') %>% group_by(parameter) %>% summarize(m=mean(value)) %>% .$m\nallx$beta2<-filter(pc,par %in% 'beta2_mu[1]') %>% group_by(parameter) %>% summarize(m=mean(value)) %>% .$m\n\ntraj<-function(ocean,coast,alpha,beta1,beta2){\n  p<-inv.logit(alpha + beta1*ocean + beta2*coast)\n  data.frame(ocean,coast,phi=p)\n}\n\nintplot<-allx %>% group_by(ID) %>% do(traj(.$ocean,.$coast,.$alpha,.$beta1,.$beta2))\n\nggplot(intplot,aes(x=ocean,y=coast,fill=phi)) + geom_tile() + theme_bw() + labs(x=\"Ocean Depth (km)\",y=\"Distance to coast (km)\") + scale_fill_gradient(low=\"blue\",high=\"red\") + ggtitle(\"Mean Probability of Feeding when Traveling\")\n```\n\n##Autocorrelation in behavior\n\n```{r,fig.height=20,fig.width=13}\n#create proper time stamp\nggplot(data=mxy,aes(x=as.POSIXct(timestamp),y=phi,col=ocean)) + geom_line(aes(group=Track),size=2.5) + labs(\"Probability of Feeding\") + theme_bw() + scale_color_continuous(low='light blue',high='black') + labs(x=\"Time\",y=\"Liklihood of Feeding\") + facet_wrap(~Animal,ncol=3,scales=\"free\") + ylim(0,1)\n```\n\n##Behavioral description\n\n## Predicted behavior duration\n```{r,fig.height=5,fig.width=14}\nrunf<-function(x){\n  #arrange by step\n  #calculate run length\n  state_change<-rle(as.numeric(x$value))\n  runl<-data.frame(Animal=unique(x$Animal),runs=state_change$lengths,Behavior=state_change$values)\n  runl$Behavior<-as.factor(runl$Behavior)\n  levels(runl$Behavior)<-c(\"Traveling\",\"Feeding\")\n  \n  return(runl)\n}\n\nruns<-pc %>% filter(parameter=='state') %>% group_by(Animal,Draw,chain) %>% do(runf(.))\n\n\n#turn steps to hours\nruns$hours<-runs$runs*step_length\n```\n\n```{r,fig.height=4}\nmr<-runs %>% group_by(Behavior) %>% summarize(mean=mean(hours),lower=quantile(hours,0.05),upper=quantile(hours,0.95))\nggplot(mr,aes(x=Behavior,y=mean,ymin=lower,ymax=upper)) + geom_pointrange(size=2) + theme_bw() + ggtitle(\"Average Duration of Behavior\") + labs(y=\"Hours\")\n\n#Every run eventually ends in a switch (that's what makes it a run)\nruns$status<-1\n\nendtrack<-function(x){\n  x[nrow(x),\"status\"]<-0\n  return(x)\n}\n\n#if track ends, status is 0 not 1\nfeedr<-runs %>% group_by(Draw,chain,Animal) %>% do(endtrack(.)) %>% filter(Behavior==\"Feeding\")\n\n#save runs to file\nwrite.csv(feedr,\"OutData/Runs.csv\")\n```\n\n##Location of Behavior\n\n```{r}\nmsp<-SpatialPointsDataFrame(cbind(mxy$x,mxy$y),data=mxy[,c(\"x\",\"y\",\"Animal\",\"phi\",\"timestamp\")],proj=CRS(\"+proj=longlat +datum=WGS84\"))\n\nr<-raster(msp,ext=extent(c(-70,-55,-66,-58))*1.1)\nres(r)<-0.1\n\nm<-rasterize(x=msp,y=r,field=\"phi\")\n\n#plotting\nfeedmap <- data.frame(rasterToPoints(m))\n\ntemp <- get_map(location=bbox(m),source=\"google\",zoom=5,maptype=\"satellite\",color = \"bw\",scale = 2)\n\nggmap(temp) + labs(fill=\"Probabilty of Feeding\")+ geom_tile(data=feedmap,aes(x=x, y=y,fill=layer),alpha=0.9) + theme_minimal() + scale_color_discrete(guide=\"none\") + scale_fill_continuous(low=\"blue\",high=\"red\")\n```\n\n#Environmental Prediction - Probability of feeding\n\n```{r}\nmice<-stack(\"InputData/MonthlyIceRaster.grd\")\n```\n\n## Bathymetry\n\n### When traveling\n```{r}\nmeanpar<-pc %>% filter(parameter %in% c('beta_mu','alpha_mu'))  %>% group_by(par) %>% summarize(mean=mean(value)) %>% dcast(...~par)\n\n#remove non-water areas\nrice[rice<0]<-NA\n\n#Traveling\ntravpar<-calc(rice,function(x){ inv.logit(1-(meanpar$`alpha_mu[1]` + meanpar$`beta_mu[1]` * x))})\ntravdf<-data.frame(rasterToPoints(travpar))\n  \nggmap(temp) + labs(fill=\"Mean Probabilty of Feeding\")+ geom_tile(data=travdf,aes(x=x, y=y,fill=layer),alpha=0.9) + scale_color_discrete(guide=\"none\") + scale_fill_continuous(low=\"blue\",high=\"red\") + xlim(-70,-50) + ylim(-67.5,-60) +  geom_tile(data=data.frame(rasterToPoints(mice[[14]])),aes(x=x,y=y,fill=Feb_2013),alpha=0.8,fill='snow2') + ggtitle(\"Feb 2013\") \n```\n\n### When Feeding\n\n```{r}\n#Feeding\nfeedpar<-calc(distc,function(x){ 1-inv.logit(meanpar$`alpha_mu[2]` + meanpar$`beta_mu[2]` * x)})\n\n#Cut by ice\nfeedf<-data.frame(rasterToPoints(feedpar))\n\nggmap(temp) + labs(fill=\"Mean Probabilty of Feeding\")+ geom_tile(data=feedf,aes(x=x, y=y,fill=layer),alpha=0.9)  + scale_color_discrete(guide=\"none\") + scale_fill_continuous(low=\"blue\",high=\"red\")+ xlim(-70,-50) + ylim(-67.5,-60) + geom_tile(data=data.frame(rasterToPoints(mice[[14]])),aes(x=x,y=y,fill=Feb_2013),alpha=0.8,fill='snow2') + ggtitle(\"Feb 2013\")+ theme(axis.text.x=element_blank(),axis.text.y=element_blank())\n\nggmap(temp) + labs(fill=\"Mean Probabilty of Feeding\")+ geom_tile(data=feedf,aes(x=x, y=y,fill=layer),alpha=0.9)  + scale_color_discrete(guide=\"none\") + scale_fill_continuous(low=\"blue\",high=\"red\") + xlim(-70,-50) + ylim(-67.5,-60)+ geom_tile(data=data.frame(rasterToPoints(mice[[19]])),aes(x=x,y=y,fill=Jul_2013),alpha=0.8,fill='snow2') + ggtitle(\"July 2013\")+ theme(axis.text.x=element_blank(),axis.text.y=element_blank())\n```\n\n## Distance to coast\n\n### When traveling\n```{r}\nmeanpar<-pc %>% filter(parameter %in% c('beta2_mu','alpha_mu'))  %>% group_by(par) %>% summarize(mean=mean(value)) %>% dcast(...~par)\n\n#remove non-water areas\nrice[rice<0]<-NA\n\n#Traveling\ntravpar<-calc(rice,function(x){ 1-inv.logit(meanpar$`alpha_mu[1]` + meanpar$`beta2_mu[1]` * x)})\ntravdf<-data.frame(rasterToPoints(travpar))\n\nggmap(temp) + labs(fill=\"Mean Probabilty of Feeding\")+ geom_tile(data=travdf,aes(x=x, y=y,fill=layer),alpha=0.9) + scale_color_discrete(guide=\"none\") + scale_fill_continuous(low=\"blue\",high=\"red\") + xlim(-70,-50) + ylim(-67.5,-60) +  geom_tile(data=data.frame(rasterToPoints(mice[[14]])),aes(x=x,y=y,fill=Feb_2013),alpha=0.8,fill='snow2') + ggtitle(\"Feb 2013\") \n```\n\n### When Feeding\n\n```{r}\n#Feeding\nfeedpar<-calc(distc,function(x){ 1-inv.logit(meanpar$`alpha_mu[2]` + meanpar$`beta2_mu[2]` * x)})\n\n#Cut by ice\nfeedf<-data.frame(rasterToPoints(feedpar))\n\nggmap(temp) + labs(fill=\"Mean Probabilty of Feeding\")+ geom_tile(data=feedf,aes(x=x, y=y,fill=layer),alpha=0.9)  + scale_color_discrete(guide=\"none\") + scale_fill_continuous(low=\"blue\",high=\"red\")+ xlim(-70,-50) + ylim(-67.5,-60) + geom_tile(data=data.frame(rasterToPoints(mice[[14]])),aes(x=x,y=y,fill=Feb_2013),alpha=0.8,fill='snow2') + ggtitle(\"Feb 2013\")+ theme(axis.text.x=element_blank(),axis.text.y=element_blank())\n\nggmap(temp) + labs(fill=\"Mean Probabilty of Feeding\")+ geom_tile(data=feedf,aes(x=x, y=y,fill=layer),alpha=0.9)  + scale_color_discrete(guide=\"none\") + scale_fill_continuous(low=\"blue\",high=\"red\") + xlim(-70,-50) + ylim(-67.5,-60)+ geom_tile(data=data.frame(rasterToPoints(mice[[19]])),aes(x=x,y=y,fill=Jul_2013),alpha=0.8,fill='snow2') + ggtitle(\"July 2013\")+ theme(axis.text.x=element_blank(),axis.text.y=element_blank())\n```\n\n##All variables\n\n```{r}\nmeanpar<-pc %>% filter(parameter %in% c('beta_mu',\"beta2_mu\",'alpha_mu'))  %>% group_by(par) %>% summarize(mean=mean(value)) %>% dcast(...~par)\n\n##Bathymetry\ns<-stack(rice,distc)\n\n#Traveling\ntravpar<-calc(s,function(x,y){ 1-inv.logit(meanpar$`alpha_mu[1]` + meanpar$`beta_mu[1]` * x[1] + meanpar$`beta2_mu[1]` * x[2])})\ntravdf<-data.frame(rasterToPoints(travpar))\n\nggmap(temp) + labs(fill=\"Mean Probabilty of Feeding\")+ geom_tile(data=travdf,aes(x=x, y=y,fill=layer),alpha=0.9)  + scale_color_discrete(guide=\"none\") + scale_fill_continuous(low=\"blue\",high=\"red\")+ geom_tile(data=data.frame(rasterToPoints(mice[[14]])),aes(x=x,y=y,fill=Feb_2013),alpha=0.8,fill='snow2') + ggtitle(\"Feb 2013\")+ theme(axis.text.x=element_blank(),axis.text.y=element_blank()) + xlim(-70,-50) + ylim(-67.5,-60) + labs(x=\"\",y=\"\")\n\n#Feeding\nfeedpar<-calc(s,function(x){ 1-inv.logit(meanpar$`alpha_mu[2]` + meanpar$`beta_mu[2]` * x[1] + meanpar$`beta2_mu[2]` * x[2])})\nfeedf<-data.frame(rasterToPoints(feedpar))\n\nggmap(temp) + labs(fill=\"Mean Probabilty of Feeding\")+ geom_tile(data=feedf,aes(x=x, y=y,fill=layer),alpha=0.9)  + scale_color_discrete(guide=\"none\") + scale_fill_continuous(low=\"blue\",high=\"red\") + geom_tile(data=data.frame(rasterToPoints(mice[[19]])),aes(x=x,y=y,fill=Jul_2013),alpha=0.8,fill='snow2') + ggtitle(\"July 2013\") + theme(axis.text.x=element_blank(),axis.text.y=element_blank())  + xlim(-70,-50) + ylim(-67.5,-60) + labs(x=\"\",y=\"\")\n```\n\n#Krill Fishery\n```{r}\nkrill<-read.csv(\"InputData/CCAMLR_aggregated_catch_C1.csv\")\n\nggmap(temp) + geom_tile(data=feedmap,aes(x=x, y=y,fill=layer),alpha=0.7) + geom_point(data=krill,aes(x=GridMidpointDegreeLon,y=GridMidpointHalfDegreeLat,size=C1KRIcatchKG/1000)) + scale_fill_continuous(low=\"blue\",high=\"red\") + labs(fill=\"Probability of Feeding\", size=\"Krill Catch (Metric Tons)\") + scale_size_continuous(range=c(0,8))\n```\n\n\n```{r}\n#notify end of run\n#size of the run\ngc()\nsave.image(\"SingleSpecies.RData\")\n```\n",
    "created" : 1466975963447.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "997761885",
    "id" : "5A1148A9",
    "lastKnownWriteTime" : 1470331188,
    "path" : "~/Whales/SingleSpecies.Rmd",
    "project_path" : "SingleSpecies.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}